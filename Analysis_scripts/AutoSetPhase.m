function [delphase,phase,fitparam] = AutoSetPhase(t0,filename,t_window)
%AutoSetPhase_vH4 - Adjust the phase defining V(in) and V(out) in DATA matrix.
%In TDTR data collection, V(in) and V(out) are defined as the signal
%amplitudes at the modulation frequency that are in-phase and out-of-phase
%of the RF lock-in phase setting. The RF lock-in phase setting should be
%matched to the phase of the modulation reference generator such that the
%change in V(out) across zero of the (pump-probe) time delay is zero.
%Since we do not expect perfect phase setting during TDTR data collection,
%we instead rotate the phase angle in software afterward. Use SetPhase to 
%do this efficiently. Use AutoSetPhase to do this automatically without
%user input, simply plotting the short- and long-time delay results.
%
% Syntax:  [delphase,phase,fitparam] = AutoSetPhase(t0,filename,t_window)
%
% Inputs:
%    data - Data matrix generated by TDTR LabVIEW data collection. The
%           format is 5-6 columns: [DelayStagePosition, TimeDelay, V(in),
%           V(out), Ratio, DetectorVoltage].
%    t0       - Zero of time delay, as judged by the user in set_t0.m
%    filename - Name of the original data file.
%    pathname - Path to save the new, shifted data file.
%    t_window - default is [-20 80] ps. Specifies the short time delay
%               domain for setting the phase.
%
% Outputs:
%    delphase - Noise in V(out) per unit rise in V(in) across zero time
%               delay, after phase shift.
%    phase    - Total phase shift applied.
%    fitparam - 3x1 matrix [m b fitOK], where y = mx+b is the linear fit 
%               to V(out). This can be useful to clean the ratio 
%               signal for high conductivity samples with low, noisy
%               V(out). "fitOK" is intended as a boolean for your own
%               record-keeping, to note a "questionable" linear fit.
% Example:
%    [delphase, phase] = AutoSetPhase(-0.3,filename, [-20 80])
%
% Other m-files required: set_t0.m, extract_interior.m, VoutLinearFit.m
% Subfunctions: SetPhaseAuto, SetPhaseManual, PhaseShift, 
%               show_Vout, show_Vout_fits.
% MAT-files required: none
%
% See also: set_t0.m, extract_interior.m, VoutLinearFit.m, PickEchoes.m

% Author: Gregory T. Hohensee
% Acknowledgement: Built from Joseph P. Feser's SetPhase.m
% University of Illinois Urbana-Champaign
% email: hohense2@illinois.edu
% Website: n/a
% Revision history: 22-March-2014
%                   14-Jul-2014 - SetPhase_vH2: t_window functionality restored
%                   18-Aug-2014 - fixed bug where ishort was defined from
%                                 tdelay_data_B (t<0) instead of _A (t>0).
%                   17-Feb-2015 - AutoSetPhase_vH3, created from SetPhase
%                                 for faster data processing.
%                   11-Jul-2016 - vH4. No changes.
%
%                   06-Sep-2021 - TK modifications to fit EILB/MQS use
%------------- BEGIN CODE --------------
%% Set standard initialization parameter
   filenameStandard = 'sampleID@MHz_objective_pump-probe_photodiode_1';
   isnorm = -1; % Default: assume no detector voltage for normalization
   option = 0; % Default: no user options selected yet.
   fitparam = [0 0 0]; % default y = mx + b, [m b fitOK] linear fit parameters
   fig1 = 101;  % initialize fignums
   fig2 = 102;

   if ishandle(fig1), close 101; end
   if ishandle(fig2), close 103; end
   
% Check input parameters
   % The first input parameter is necessary
   if nargin < 1, error('At least input the TDTR raw data file!'); end
   if nargin < 2, warning('No filename, defaulting to standard for saved file.'); 
   filename = filenameStandard; end
   if nargin < 3, t_window = [-20 80]; end
   
   if ~ischar(filename)
       error('Bad input; check that filename and pathname are text strings');
   end

   data_init = load(filename);
   if isstruct(data_init)
       data = struct2array(data_init.Data);
       data
   else
       data = data_init;
   end
   
   if length(data(1,:)) < 5
       error('Nonstandard data matrix format.');
   end


%% Interpret data
Encodercount=data(:,1);
tdelay_raw=data(:,2) - t0; %imported in picoseconds.
Vin_raw=data(:,3); %Units (uV)
Vout_raw=data(:,4);
ratio_raw=data(:,5);

% if there's a sixth column in the data, assume it is DetectorVoltage (mV)
if length(data(1,:)) > 5 
    detV_raw = data(:,6);
    isnorm = 0; % default representation is raw V(out), not normalized.
    normtext = 'raw';
else
    normtext = 'raw';
end

%Choose range of time delays
tdelay_min   = t_window(1);   % default -20 ps, min time delay (ps)
tdelay_short = t_window(2);   % default 80 ps, max time delay for short-range V(out) plot
tdelay_max   = 4000;          % max time delay for long-range V(out) plot

%Extract Points in that time range, separately for t < t0 and t > t0

%t < t0
%[~,            ratio_data_B]=extract_interior(tdelay_raw,ratio_raw,tdelay_min,t0);
[~,            Vin_data_B]=extract_interior_V4(tdelay_raw,Vin_raw,tdelay_min,0);
[tdelay_data_B,Vout_data_B]=extract_interior_V4(tdelay_raw,Vout_raw,tdelay_min,0);
if length(data(1,:)) > 5
    [~,            detV_data_B]=extract_interior_V4(tdelay_raw,detV_raw,tdelay_min,0);
    normB = (detV_data_B ./ detV_data_B(1)).^2;
end

%t>t0
%[~,            ratio_data_A]=extract_interior(tdelay_raw,ratio_raw,t0,tdelay_max);
[~,            Vin_data_A]=extract_interior_V4(tdelay_raw,Vin_raw,0,tdelay_max);
[tdelay_data_A,Vout_data_A]=extract_interior_V4(tdelay_raw,Vout_raw,0,tdelay_max);
if length(data(1,:)) > 5
    [~,            detV_data_A]=extract_interior_V4(tdelay_raw,detV_raw,0,tdelay_max);
    normA = (detV_data_A ./ detV_data_B(1)).^2; % denominator is detV_data_B(1), NOT data_A!
end

% Get index of time delay nearest tdelay_short, the max time for short-range plot.
[~,ishort] = min(abs(tdelay_data_A - tdelay_short));

Vout_shifted_A = Vout_data_A;
Vin_shifted_A  = Vin_data_A;
Vout_shifted_B = Vout_data_B;
Vin_shifted_B  = Vin_data_B;

%% Present the short- and long-time V(out) to the user to inform
% the user's decision about how to set the phase.

% % Initialize the two V(out) figures % %
set(0,'Units','pixels') 
scnsize = get(0,'ScreenSize');

h1 = figure(fig1);

% The figure Position property only includes the drawable extent of the window, 
%exclusive of the window borders. Obtain the entire window's size from the 
%OuterPosition property, and compare the two:
position = get(h1,'Position');
outerpos = get(h1,'OuterPosition');
borders = outerpos - position;
%The left, right, and bottom borders are each 4 pixels wide. The top border, 
%which contains a menu bar and a figure toolbar is 75-4, or 71 pixels wide.


%Define the desired size and location of the figures. Leave a space equal 
%to their border width between them:
edge = -borders(1)/2; % half a border's width
pos1 = [edge,... % left
        scnsize(4) * (2/3),... % bottom
        scnsize(3)/3 - edge,... % width
        scnsize(4)/3]; % height
pos2 = [scnsize(3)/3 + edge,... % right of fig1
        pos1(2),... % same bottom
        pos1(3),... % same width
        pos1(4)]; % same height
    
%Reposition the two figures by changing both of their OuterPosition properties:
set(h1,'OuterPosition',pos1)

% populate the V(out) figures with data
show_Vout(tdelay_data_A, Vout_data_A, Vout_shifted_A, ...
          tdelay_data_B, Vout_data_B, Vout_shifted_B, ...
          tdelay_min, tdelay_short, tdelay_max,fig1);

%% Initialize [res delphase] for zero phase shift.
phase = 0; % initialize total phase shift
[res, delphase] = PhaseShift(phase,ishort,Vin_data_A, Vout_data_A, ...
                                          Vin_data_B, Vout_data_B);

% Compose command text
if isnorm ~= -1 % indicates presence of detector voltage data
    commandtext = strcat('Enter (s) to auto-set phase by short time data, ', ...
                      '\n (p) to manually set the phase,', ...
                      '\n (n) to switch to/from normalized V(out)', ...
                      '\n (f) to determine a linear fit to shifted V(out)', ...
                      '\n or (e) to end program: ');
else
    commandtext = strcat('Enter (s) to auto-set phase by short time data,', ...
                  '\n (p) to manually set the phase,', ...
                  '\n (f) to determine a linear fit to shifted V(out),', ...
                  '\n or (e) to end program: ');
end

%%
clear option;
done = 0;
while ~done
    % PhaseShift takes the absolute value of the residual to accommodate
    % fminsearch. For manual fitting, I want the sign of the residual.
    res = mean(Vout_shifted_A(1:ishort))-mean(Vout_shifted_B);
    
    % compose status text
    st1 = sprintf('Working with %s V(out)',normtext);
    st2 = sprintf('\n V(out) fit parameters y = mx + b: m = %0.3d uV/ps, b = %0.2f uV', fitparam(1),fitparam(2));
    st3 = sprintf('\n Total phase shift applied: %0.2f degrees', phase);
    st4 = sprintf('\n mean difference between [%i 0] and [0 %i] ps: %0.3f', ...
                            tdelay_min, tdelay_short, res);
    statustext = strcat(st1, st2, st3, st4);
    fprintf(statustext) % print status text
    fprintf('\n\n')
    
    % Get and clean user's decision
    cleaning = 1;
    
    while cleaning
        %option = input(commandtext,'s');
        if ~exist('option','var')
            option = 's' ;
        else
            option = 'e';
        end % automatic phase set all
        
        if length(option) > 1
            warning('Too many characters.')
        else
           if isempty(option)
               warning('Invalid option, try again.')
               cleaning = 0;
           elseif sum(option == ['s', 'p', 'n', 'f', 'e']) == 0
               warning('Invalid option, try again.')
           else
               cleaning = 0; % single valid character, ok
           end
        end
    end

    % Act on user's decision
    switch option
        case 's'
            [res, delphase, dphase,...
                Vin_shifted_A, Vout_shifted_A, ...
                Vin_shifted_B, Vout_shifted_B] ...
                = SetPhaseAuto(tdelay_data_A,Vin_data_A,Vout_data_A,...
                               tdelay_data_B,Vin_data_B,Vout_data_B,...
                               tdelay_min, tdelay_short, tdelay_max,fig1);
             phase = 0 + dphase; % no memory of prior phase shifts
             
        case 'p'
            [res, delphase, dphase,...
                Vin_shifted_A, Vout_shifted_A, ...
                Vin_shifted_B, Vout_shifted_B] ...
                = SetPhaseManual(tdelay_data_A,Vin_data_A,Vout_data_A,...
                                               Vin_shifted_A, Vout_shifted_A, ...
                                 tdelay_data_B,Vin_data_B,Vout_data_B,...
                                               Vin_shifted_B, Vout_shifted_B, ...
                                 tdelay_min, tdelay_short, tdelay_max,fig1);
             phase = phase + dphase;
        case 'n'
            % confirm that data includes detector voltage information
            if isnorm ~= -1
                if isnorm % de-normalize shifted data
                    normtext = 'raw';
                    isnorm = 0;
                    Vin_shifted_A = Vin_shifted_A ./ normA;
                    Vout_shifted_A = Vout_shifted_A ./ normA;
                    Vin_shifted_B = Vin_shifted_B ./ normB;
                    Vout_shifted_B = Vout_shifted_B ./ normB;
                    
                    Vin_data_A = Vin_data_A ./ normA;
                    Vout_data_A = Vout_data_A ./ normA;
                    Vin_data_B = Vin_data_B ./ normB;
                    Vout_data_B = Vout_data_B ./ normB;
                else % normalized shifted data
                    normtext = 'normalized';
                    isnorm = 1;
                    Vin_shifted_A = Vin_shifted_A .* normA;
                    Vout_shifted_A = Vout_shifted_A .* normA;
                    Vin_shifted_B = Vin_shifted_B .* normB;
                    Vout_shifted_B = Vout_shifted_B .* normB;
                    
                    Vin_data_A = Vin_data_A .* normA;
                    Vout_data_A = Vout_data_A .* normA;
                    Vin_data_B = Vin_data_B .* normB;
                    Vout_data_B = Vout_data_B .* normB;
                end
                % Update the V(out) plots
                show_Vout(tdelay_data_A, Vout_data_A, Vout_shifted_A, ...
                          tdelay_data_B, Vout_data_B, Vout_shifted_B, ...
                          tdelay_min, tdelay_short, tdelay_max,fig1);
                fprintf('\n\n');      
            else
                warning('The data does not include detector voltage!')
            end

        case 'f' % manually adjust the linear fit
            Vin_shifted = [Vin_shifted_B;Vin_shifted_A];
            Vout_shifted = [Vout_shifted_B;Vout_shifted_A];
            ratio_shifted = -Vin_shifted ./ Vout_shifted;
            datatemp = [Encodercount,(tdelay_raw-t0),Vin_shifted,Vout_shifted,ratio_shifted];
            [Msol,fitOK] = VoutLinearFit_vH4(datatemp);
            m = Msol(1);
            b = Msol(2);
            exportfit=input('Pass this fit to your process file? (1 for yes, 0 for no)\n');
            if exportfit
                fitparam = [m,b, fitOK]; % This is the only place where fitparam is nonzero
            end
        case 'e' % save UN-NORMALIZED shifted data, end program
            % At this point [res, delphase, phase] should have been
            % calculated by the user's commands or by default.
            
            % Apply the final phase shift to the original raw Vin, Vout
            radphase = (pi/180)*phase;
            V=(Vin_raw+sqrt(-1)*Vout_raw)*exp(sqrt(-1)*radphase);
                
            Vin_shifted=real(V);
            Vout_shifted=imag(V);
            ratio_shifted=-Vin_shifted./Vout_shifted;
            
            figure(fig2)
            semilogx(tdelay_raw,ratio_raw,'b-',tdelay_raw,ratio_shifted,'g-')
            axis([10 4000 0 1.2*max([ratio_raw;ratio_shifted])]);

            legend('Ratio_{raw}','Ratio_{shifted}')

            xlabel('Time delay (ps)');
            ylabel('Ratio');
            
            %exportind=input('Save shifted data? (1 for yes, 0 for no)\n');
            exportind = 1; % auto save all
            if exportind==1
                fileprefix = strsplit(filename,'.');
                fileprefix = fileprefix{1};
                % Uncomment next three lines if raw data file has suffix
                %a=numel(filename);
                %fileprefix=filename(1:(a-4));
                %filesuffix=filename((a-3):a);

                if isnorm ~= -1
%                     Data = [Encodercount,(tdelay_raw-t0),...
%                                     Vin_shifted,Vout_shifted,ratio_shifted,...
%                                     detV_raw];

                    Data.stagePosition = Encodercount;
                    Data.tdelay = tdelay_raw-t0;
                    Data.Vin = Vin_shifted;
                    Data.Vout = Vout_shifted;
                    Data.Ratio = ratio_shifted;
                    Data.Vdet = detV_raw;
                else
%                     Data = [Encodercount,(tdelay_raw-t0),...
%                                        Vin_shifted,Vout_shifted,ratio_shifted];

                    Data.stagePosition = Encodercount;
                    Data.tdelay = tdelay_raw-t0;
                    Data.Vin = Vin_shifted;
                    Data.Vout = Vout_shifted;
                    Data.Ratio = ratio_shifted;
                end
                
                file_shifted=strcat(fileprefix,'_SHIFTED.mat');
                %dlmwrite(file_shifted,Data,'delimiter','\t')
                save(file_shifted,'Data')
                fprintf('exporting file to:\n');
                fprintf('%s\n',file_shifted);
            end
            done = 1;
    end % end of switch option case structure
end % end while loop for user commands
end % END OF MAIN FUNCTION %

% BEGIN SUBFUNCTIONS %

%% Manual phase-setting subfunction. Same basic functionality as original
function [res, delphase, phase, Vin_shifted_A, Vout_shifted_A, ...
                                Vin_shifted_B, Vout_shifted_B] ...
               = SetPhaseManual(tdelay_data_A,Vin_data_A,Vout_data_A,...
                                               Vin_shifted_A, Vout_shifted_A, ...
                                 tdelay_data_B,Vin_data_B,Vout_data_B,...
                                               Vin_shifted_B, Vout_shifted_B, ...
                                 tdelay_min, tdelay_short, tdelay_max,fig1)

% Get index of time delay nearest tdelay_short, the max time for short-range plot.
[~,ishort] = min(abs(tdelay_data_A - tdelay_short));

phase=0; % Initialize phase shift
test=1;
while test~=0
    % Plot V(out) over short and long time delays.
    show_Vout(tdelay_data_A, Vout_data_A, Vout_shifted_A, ...
              tdelay_data_B, Vout_data_B, Vout_shifted_B, ...
              tdelay_min, tdelay_short, tdelay_max, fig1);
    
    % Plot linear fits for additional guidance.
    show_Vout_fits(tdelay_data_A, tdelay_data_B,...
                   Vout_shifted_A, Vout_shifted_B, fig1);
    
    % Get user input for phase shift.
    dphase=input('Enter change in phase (deg), enter 0 to end:\n');
    phase=phase+dphase;
    test=dphase; 
    
    % Execute phase shift, get residual across t0 and phase uncertainty
    [res, delphase, Vin_shifted_A, Vout_shifted_A, ...
                    Vin_shifted_B, Vout_shifted_B] ...
                    = PhaseShift(phase,ishort,Vin_data_A, Vout_data_A, ...
                                              Vin_data_B, Vout_data_B);
                                   
    % Report residual and phase uncertainty
    fprintf('residual = %0.3f, delphase = %0.3f\n\n',res,delphase)
end

end


%% Automatic phase-setting subfunction.
function [res, delphase, phase_sol, Vin_shifted_A, Vout_shifted_A, ...
                                    Vin_shifted_B, Vout_shifted_B] ...
                    = SetPhaseAuto(tdelay_data_A,Vin_data_A,Vout_data_A,...
                                   tdelay_data_B,Vin_data_B,Vout_data_B,...
                                   tdelay_min, tdelay_short, tdelay_max,fig1)
%%
% Get index of time delay nearest tdelay_short, the max time for short-range plot.
[~,ishort] = min(abs(tdelay_data_A - tdelay_short));

% search algorithm to minimize residual across t0 in PhaseShift subfunction
% This line does not change the shifted arrays.
phase_sol = fminsearch(@(X) PhaseShift(X,ishort,...
                                       Vin_data_A, Vout_data_A,...
                                       Vin_data_B, Vout_data_B), 0);

% Execute phase shift, get residual across t0 and phase uncertainty
[res, delphase, Vin_shifted_A, Vout_shifted_A, ...
                Vin_shifted_B, Vout_shifted_B] ...
                = PhaseShift(phase_sol,ishort,Vin_data_A, Vout_data_A, ...
                                              Vin_data_B, Vout_data_B);
                               
% Report residual and phase uncertainty
fprintf('residual = %0.5g, delphase = %0.5g\n\n',res,delphase)

% Display result of automatic phase shift
show_Vout(tdelay_data_A, Vout_data_A, Vout_shifted_A, ...
          tdelay_data_B, Vout_data_B, Vout_shifted_B, ...
          tdelay_min, tdelay_short, tdelay_max, fig1);
  
      
%DISABLED FOR NOW (06092021 - TK): EILB-MQS setup has probe on the delay stage -> Vout will not be linear as in the pump on the stage -case     
% show_Vout_fits(tdelay_data_A, tdelay_data_B,...
%                Vout_shifted_A, Vout_shifted_B, fig1);
end



%% Simple subfunction: execute given phase shift on V(out), V(in).
function [res, delphase, Vin_shifted_A, Vout_shifted_A, ...
                         Vin_shifted_B, Vout_shifted_B] ...
                = PhaseShift(phase,ishort,Vin_data_A, Vout_data_A, ...
                                          Vin_data_B, Vout_data_B)
    radphase=pi/180*phase; % in radians
    
    
    % Complex representation of phase shift
    VB=(Vin_data_B+sqrt(-1)*Vout_data_B)*exp(sqrt(-1)*radphase);
    VA=(Vin_data_A+sqrt(-1)*Vout_data_A)*exp(sqrt(-1)*radphase);
    
    % update V(in), V(out) for phase shift
    Vin_shifted_A=real(VA);
    Vout_shifted_A=imag(VA);
    Vin_shifted_B=real(VB);
    Vout_shifted_B=imag(VB);
    
    % Calculate stats for the shifted V(out)
    res=abs(mean(Vout_shifted_A(1:ishort))-mean(Vout_shifted_B));
    noiseY=std([Vout_shifted_A(1:ishort);Vout_shifted_B]);
    delX=max(Vin_shifted_A(1:ishort))-min(Vin_shifted_B);
    delphase=2*noiseY/delX*180/pi;
end



%% Subfunction for displaying V(out) and shifted V(out) information
% to inform user's decision about how to proceed in setting the phase
function [] = show_Vout(tdelay_data_A, Vout_data_A, Vout_shifted_A, ...
                        tdelay_data_B, Vout_data_B, Vout_shifted_B, ...
                        tdelay_min, tdelay_short, tdelay_max, fig1)

% % Populate the two figures with content % %
figure(fig1); % short time delay plot
subplot(2,1,1)
plot(tdelay_data_A,Vout_data_A,'b-',tdelay_data_A,Vout_shifted_A,'g-',...
     tdelay_data_B,Vout_data_B,'b-',tdelay_data_B,Vout_shifted_B,'g-')
 
legend('V_{out}', 'V_{out}, shifted')
 
% Get index of time delay nearest tdelay_short, the max time for short-range plot.
[~,ishort] = min(abs(tdelay_data_A - tdelay_short));

yshortmin = min([Vout_data_A(1:ishort);Vout_shifted_A(1:ishort);Vout_data_B;Vout_shifted_B]);
yshortmax = max([Vout_data_A(1:ishort);Vout_shifted_A(1:ishort);Vout_data_B;Vout_shifted_B]);
axis([tdelay_min tdelay_short yshortmin yshortmax]);

xlabel('Time delay (ps)');
ylabel('V_{out} (uV)');
title('Short time delay')

figure(fig1); % long time delay plot
subplot(2,1,2)
plot(tdelay_data_A,Vout_data_A,'b-',tdelay_data_A,Vout_shifted_A,'g-',...
     tdelay_data_B,Vout_data_B,'b-',tdelay_data_B,Vout_shifted_B,'g-')
 
legend('V_{out}', 'V_{out}, shifted')
 
ylongmin = min([Vout_data_A;Vout_shifted_A;Vout_data_B;Vout_shifted_B]);
ylongmax = max([Vout_data_A;Vout_shifted_A;Vout_data_B;Vout_shifted_B]);
axis([tdelay_min tdelay_max ylongmin ylongmax]);

xlabel('Time delay (ps)');
ylabel('V_{out} (uV)');
title('Full time delay')
end



%% Subfunction for plotting linear fits in the show_Vout figures;
% separated from show_Vout() to save computation time if desired
function [] = show_Vout_fits(tdelay_data_A, tdelay_data_B,...
                             Vout_shifted_A, Vout_shifted_B, fig1)

% For guidance, produce a linear fit to the long-time shifted V(out)
%[~,ns] = min(abs(tdelay_data_A - 1000));
%tf = length(tdelay_data_A);
%FL = fit(tdelay_data_A(ns:tf), Vout_shifted_A(ns:tf),'poly1');

% For guidance, produce a linear fit to the entire shifted V(out)
td = vertcat(tdelay_data_B, tdelay_data_A);
%Vout = vertcat(Vout_shifted_B, Vout_shifted_A);
%FA = fit(td, Vout, 'poly1');

% For guidance, plot the mean value of the negative time delay V(out)
figure(fig1);
hold on;
havg = plot(td, ones(length(td),1)*mean(Vout_shifted_B),'r-');
hold off;

%figure(fig2);
%hold on;
%hfl = plot(FL,'r-');
%hfa = plot(FA,'r-');
%hold off;
%set(hfl,'LineWidth',2);
%set(hfa,'LineWidth',2);
%legend('off');
%legend(hfl, 'fit > 1 ns');
%legend(hfa, 'fit all');
end
%------------- END OF CODE --------------
